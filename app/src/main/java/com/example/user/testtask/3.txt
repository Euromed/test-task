import java.util.*;
import java.io.*;
import java.math.*;

/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player {

    static State state = null;
    static int width, height;

    static long enterTime = 0;

    public static void tstamp() {
        enterTime = System.nanoTime();
    }

    public static void dprint(String s) {
        long d = System.nanoTime() - enterTime;
        if (d > 10000000) {
            System.err.println(s + d);
        }
    }

    public static void main(String args[]) {
        Scanner in = new Scanner(System.in);
        int width = in.nextInt();
        int height = in.nextInt();
        int my_id = in.nextInt();
        in.nextLine();

        state = new State(width, height, my_id);

        // game loop
        while (true) {
            for (int i = 0; i < height; i++) {
                String row = in.nextLine();
                state.init_row(i, row);
            }

            int entities = in.nextInt();
            for (int i = 0; i < entities; i++) {
                int entity_type = in.nextInt();
                int owner = in.nextInt();
                int x = in.nextInt();
                int y = in.nextInt();
                int param1 = in.nextInt();
                int param2 = in.nextInt();
                state.put_entity(x, y, entity_type, owner, param1, param2);
            }
            in.nextLine();

            String action = do_move();
            // Write an action using System.out.println()
            // To debug: System.err.println("Debug messages...");

            System.out.println(action);
        }
    }

    static String do_move() {

        Tester tester = new Tester();
        Strategy s = tester.find_strategy(state);
        String rv = (s.explode ? "BOMB " : "MOVE ") + (state.my_x+s.dx) + " " + (state.my_y+s.dy);
        return (rv);
    }

}

class Item {
    public static final int TYPE_PLAYER             = 0;
    public static final int TYPE_BOMB               = 1;
    public static final int TYPE_ITEM               = 2; // используется только при инициализации
    public static final int TYPE_EXTRA_BOMB         = 3;
    public static final int TYPE_EXTRA_RANGE        = 4;

    public int x;
    public int y;
    public int type;
    public int owner;
    public int param1;
    public int param2;

    public Item (int x, int y, int type, int owner, int param1, int param2) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.owner = owner;
        this.param1 = param1;
        this.param2 = param2;
    }

    public Item() {
    }

    public int compact() {
        return (compact(x, y, type, owner, param1, param2));
    }

    public static int compact(int x, int y, int type, int owner, int param1, int param2) {
        if (param1 > 15) {
            param1 = 15;
        }
        if (param2 > 15) {
            param2 = 15;
        }
        return(x << 20 | y << 16 | type << 12 | owner << 8 | param1 << 4 | param2);
    }

    public static Item expand (int it) {
        return (expand(it, null));
    }

    public static Item expand(int it, Item dst) {
        if (dst == null) {
            dst = new Item();
        }
        dst.x = (it >> 20) & 0xf;
        dst.y = (it >> 16) & 0xf;
        dst.type = (it >> 12) & 0xf;
        dst.owner = (it >> 8) & 0xf;
        dst.param1 = (it >> 4) & 0xf;
        dst.param2 = it & 0xf;
        return (dst);
    }
}

class Field implements Cloneable {
    public final int width;
    public final int height;
    public int[] field = null;

    public Field (int width, int height) {
        this.width = width;
        this.height = height;
        field = new int[width*height];
    }

    public int get(int x, int y) {
        return (field[x + y*width]);
    }

    public void set(int x, int y, int val) {
        field[x + y*width] = val;
    }

    public int size() {
        return field.length;
    }

    public Object clone() {
        Field copy = null;
        try {
            copy = (Field)super.clone();
            copy.field = field.clone();
        }
        catch (Exception e) {
            System.err.println("Can't clone some objects");
            System.exit(1);
        }
        return (copy);
    }
}

class State implements Cloneable {
    public static final int CELL_EMPTY              = 0;
    public static final int CELL_BOX                = 1;
    public static final int CELL_BOMB               = 2;
    public static final int CELL_EXTRA_BOMB         = 3;
    public static final int CELL_EXTRA_RANGE        = 4;
    public static final int CELL_EXPLOSION          = 5;
    public static final int CELL_WALL               = 6;
    public static final int CELL_PLAYER_0           = 7;
    public static final int CELL_PLAYER_1           = 8;

    public final int width;
    public final int height;
    public final int my_id;
    public int my_x, my_y;
    public int available_bombs = 0;
    public int bombs_unavailability_time = 10;
    public int bomb_range = 0;
    public int max_bomb_count = 0;
    public int score = 0;
    public int strategy = 0;
    private Field grid = null;
    private ArrayList<Integer> items = null;

    public State (int width, int height, int my_id) {
        this.width = width;
        this.height = height;
        this.my_id = my_id;
    }

    public void init_row(int n, String row) {
        if (grid == null) {
            grid = new Field(width, height);
        }
        int length = row.length();
        int start_pos = n * width;
        for (int i = 0; i < length; ++i) {
            int cell = CELL_EMPTY;
            char ch = row.charAt(i);
            switch (ch) {
                case '.':
                    break;
                default:
                    cell = CELL_BOX;
                    break;
            }
            grid.field[start_pos+i] = cell;
        }
    }

    public int get_cell(int x, int y) {
        return (grid.get(x, y));
    }

    void set_cell(int x, int y, int type) {
        grid.set(x, y, type);
    }

    public void put_entity (int x, int y, int type, int owner, int param1, int param2) {
        if (items == null) {
            items = new ArrayList<Integer>(32);
        }
        if (type == Item.TYPE_ITEM && get_cell(x, y) == CELL_EMPTY) {
            set_cell(x, y, param1 == 1 ? CELL_EXTRA_RANGE : CELL_EXTRA_BOMB);
            return;
        }
        if (type == Item.TYPE_PLAYER) {
            if (owner == my_id) {
                my_x = x;
                my_y = y;
                available_bombs = param1;
                max_bomb_count += param1;
                bomb_range = param2;
            }
            int cell = get_cell(x, y);
            if (owner < my_id || cell == CELL_EMPTY || cell == CELL_EXTRA_RANGE || cell == CELL_EXTRA_BOMB) {
                set_cell(x, y, CELL_PLAYER_0+owner);
            }
            return;
        }
        if (type == Item.TYPE_BOMB) {
            set_cell(x, y, CELL_BOMB);
            if (owner == my_id && param1 < bombs_unavailability_time) {
                bombs_unavailability_time = param1;
                ++max_bomb_count;
            }
        }
        items.add(Item.compact(x, y, type, owner, param1, param2));
    }

    public int item_count() {
        return (items.size());
    }

    public Item get_item (int n, Item dst) {
        int it = items.get(n);
        return (Item.expand(it, dst));
    }

    public void remove_item(int n) {
        items.remove(n);
    }

    public void modify_item(int n, Item it) {
        items.set(n, it.compact());
    }

    @Override
    public Object clone()  {
        State copy = null;
        try {
            copy = (State)super.clone();
            copy.grid = (Field)grid.clone();
            copy.items = (ArrayList<Integer>)items.clone();
        }
        catch (Exception e) {
            System.err.println("Can't clone some objects");
            System.exit(1);
        }
        return (copy);
    }

    int find_item_first(int x, int y, Item it) {
        return (find_item_next(-1, x, y, it));
    }

    int find_item_next(int last, int x, int y, Item it) {
        int count = item_count();
        for (int i = last+1; i < count; ++i) {
            it = get_item(i, it);
            if (it.x == x && it.y == y) {
                return (i);
            }
        }
        return (-1);
    }
}

class Life implements Cloneable {

    public final int width;
    public final int height;
    private int[][] life = null;

    public Life(State state) {
        width = state.width;
        height = state.height;
        life = new int[width*height][];
    }

    public int[] get(int x, int y) {
        return (life[x + y*width]);
    }

    public void add(int x, int y, int time) {
        int n = x + y*width;
        int[] cell_life = life[n];
        if (cell_life == null) {
            int[] new_cell_life = new int[1];
            new_cell_life[0] = time;
            life[n] = new_cell_life;
            return;
        }
        if (Arrays.binarySearch(cell_life, time) >= 0) {
            return;
        }
        int s = cell_life.length;
        int[] new_cell_life = new int[s+1];
        System.arraycopy(cell_life, 0, new_cell_life, 0, s);
        new_cell_life[s] = time;
        Arrays.sort(new_cell_life);
        life[n] = new_cell_life;
        return;
    }

    public boolean eq(int x, int y, int time) {
        int[] cell_life = life[x + y*width];
        if (cell_life == null) {
            return (false);
        }
        return (cell_life.length == 1 && cell_life[0] == time ||
                Arrays.binarySearch(cell_life, time) >= 0);
    }

    public boolean le(int x, int y, int time) {
        int[] cell_life = life[x + y*width];
        if (cell_life == null) {
            return (false);
        }
        return (cell_life[0] <= time);
    }

    @Override
    public Object clone() {
        Life copy = null;
        try {
            copy = (Life)super.clone();
            copy.life = life.clone();
        }
        catch (Exception e) {
            System.err.println("Can't clone some objects");
            System.exit(1);
        }
        return (copy);
    }
}

class Rules implements Cloneable {

    public static final int INITIAL_BOMB_LIFE = 9;

    public State state = null;;
    public Life life = null;

    public Rules (State state) {
        this.state = state;
        life = new Life(state);
        init_life();
    }

    private void init_life() {
        int n = state.item_count();
        int[] map = new int[n];
        int map_size = -1;
        Item it = null;
        for (int i = 0; i < n; ++i) {
            it = state.get_item(i, it);
            if (it.type == Item.TYPE_BOMB) {
                int key = it.param1 << 20 | it.owner << 16 | i;
                map[++map_size] = key;
            }
        }
        if (map_size > 1) {
            Arrays.sort(map, 0, map_size-1);
        }
        for (int i = 0; i < map_size; ++i) {
            it = state.get_item(map[i] & 0xffff, it);
            explode_bomb(it, -1);
        }
    }

    private static class Explode_bomb_data {
        boolean my_bomb;
        int owner;
        int time;
        int score = 0;
    }

    int explode_bomb(Item b, int time) {
        if (life.le(b.x, b.y, b.param1)) {
            return (0);
        }
        Explode_bomb_data data = new Explode_bomb_data();
        data.my_bomb = b.owner == state.my_id;
        data.owner = b.owner;
        if (time < 0) {
            time = b.param1;
        }
        data.time = time;
        int range = b.param2-1;
        int fin;
        Item it = null;

        fin = b.x - range;
        if (fin < 0) {
            fin = 0;
        }
        for (int i = b.x; i >= fin && explode_cell(i, b.y, data); --i)
            ;

        fin = b.x + range;
        if (fin >= state.width) {
            fin = state.width - 1;
        }
        for (int i = b.x+1; i <= fin && explode_cell(i, b.y, data); ++i)
            ;

        fin = b.y - range;
        if (fin < 0) {
            fin = 0;
        }
        for (int i = b.y-1; i >= fin && explode_cell(b.x, i, data); --i)
            ;

        fin = b.y + range;
        if (fin >= state.height) {
            fin = state.height - 1;
        }
        for (int i = b.y+1; i <= fin && explode_cell(b.x, i, data); ++i)
            ;
        return (data.score);
    }

    boolean explode_cell (int x, int y, Explode_bomb_data data) {
        if (life.le(x, y, data.time)) {
            life.add(x, y, data.time);
            return (true);
        }
        boolean rv = true;
        Item it = null;
        switch (state.get_cell(x, y)) {
            case State.CELL_BOMB:
                int n = state.find_item_first(x, y, it);
                while (n != -1) {
                    it = state.get_item(n, it);
                    if (it.type == Item.TYPE_BOMB && it.owner != data.owner) {
                        data.score += explode_bomb(it, data.time);
                    }
                    n = state.find_item_next(n, x, y, it);
                }
                life.add(x, y, data.time);
                rv = false;
                break;
            case State.CELL_BOX:
                if (data.my_bomb) {
                    ++data.score;
                }
                life.add(x, y, data.time);
                rv = false;
                break;
            case State.CELL_EMPTY:
            case State.CELL_EXPLOSION:
                life.add(x, y, data.time);
                break;
            case State.CELL_WALL:
                rv = false;
                break;
            default:
                life.add(x, y, data.time);
                rv = false;
                break;
        }
        return (rv);
    }

    public boolean move_hero(Score score, int dx, int dy) {
        int x = score.x + dx;
        int y = score.y + dy;
        int cell = State.CELL_EMPTY;
        if (x >= 0 && x < state.width && y >= 0 && y < state.height &&
            (life.le(x, y, score.step) || (cell = state.get_cell(x, y)) != State.CELL_BOX &&
             cell != State.CELL_WALL && cell != State.CELL_BOMB)) {
            score.x = x;
            score.y = y;
            ++score.step;
            if (score.bombs_unavailability_time == 0) {
                if (--score.bombs_unavailability_time == 0) { // modify for bomb chain
                    ++score.available_bombs;
                }
            }
            if (cell == State.CELL_EXTRA_BOMB) {
                ++score.available_bombs;
                ++score.max_bomb_count;
                life.add(x, y, score.step);
            }
            if (cell == State.CELL_EXTRA_RANGE) {
                ++score.bomb_range;
                life.add(x, y, score.step);
            }
            return (true);
        }
        return (false);
    }

    public boolean place_bomb(Score score) {
        if (score.available_bombs == 0) {
            score.step += score.bombs_unavailability_time;
            score.bombs_unavailability_time = INITIAL_BOMB_LIFE;
        }
        else if (score.available_bombs-- == score.max_bomb_count) { // modify for bomb chain
            score.bombs_unavailability_time = INITIAL_BOMB_LIFE;
        }
        int bomb_life = score.step + INITIAL_BOMB_LIFE;
        Item bomb = new Item(score.x, score.y, Item.TYPE_BOMB, state.my_id, bomb_life, score.bomb_range);
        int bomb_score = explode_bomb(bomb, bomb_life);
//        if (bomb_score > 0) {
            score.score += bomb_score;
            score.time = Math.max(score.time, bomb_life);
//        }
        ++score.placed_bomb_count;
        return (true);
    }

    @Override
    public Object clone() {
        Rules copy = null;
        try {
            copy = (Rules)super.clone();
            copy.state = (State)state.clone();
            copy.life = (Life)life.clone();
        }
        catch (Exception e) {
            System.err.println("Can't clone some objects");
            System.exit(1);
        }
        return (copy);
    }
}

class Score implements Cloneable {
    int strategy;
    int x, y;
    int step;
    int score;
    int time;
    int available_bombs;
    int bombs_unavailability_time;
    int bomb_range;
    int max_bomb_count;
    int placed_bomb_count;
    Rules rules;

    boolean gt(Score score) {
        if (score == null) {
            return (true);
        }
/*        int compare = this.score * score.time - score.score * time;
        return (compare > 0 ||
                compare == 0 &&
                    (/*time < score.time ||* / step < score.step ||
                     max_bomb_count > score.max_bomb_count ||
                     bomb_range > score.bomb_range
                    )
               );*/
        return (this.score > score.score ||
                this.score == score.score && (step < score.step  ||
                step == score.step &&
                    (max_bomb_count > score.max_bomb_count || bomb_range > score.bomb_range)
                ));
    }

    boolean gt_short(Score score) {
//        int compare = this.score * score.time - score.score * time;
//        return (compare > 0 || compare == 0 && (/*time < score.time ||*/ step < score.step));
        return (this.score > score.score ||
                this.score == score.score && step < score.step);
    }

    boolean eq_level(Score score) {
        return (bomb_range == score.bomb_range &&
                max_bomb_count == score.max_bomb_count &&
                placed_bomb_count == score.placed_bomb_count);
    }

    @Override
    public Object clone() {
        Object copy = null;
        try {
            copy = super.clone();
        }
        catch (Exception e) {
            System.err.println("Can't clone some objects");
            System.exit(1);
        }
        return (copy);
    }

    public String toString() {
        return ("{" + strategy + ", (" + x + "," + y + "), step=" + step + " score=" +
            score + " time=" + time + " level=(" + placed_bomb_count + "," + max_bomb_count + "," + bomb_range + ")");
    /*int available_bombs;
    int bombs_unavailability_time;*/
    }
}

class ScoreArray extends ArrayList<Score> {
}

class ScoreField {
    public final int width;
    public final int height;
    private ScoreArray[] field;
    private ScoreArray[] step;

    public ScoreField (State state) {
        width = state.width;
        height = state.height;
        field = new ScoreArray[width*height];
        step = new ScoreArray[width*height];
    }

    public ScoreArray get(int x, int y) {
        return (field[x + y*width]);
    }

    public void put(Score score) {
        int n = score.x + score.y*width;
        ScoreArray cell = field[n];
        if (score.bomb_range > Tester.MAX_BOMB_RANGE) {
            score.bomb_range = Tester.MAX_BOMB_RANGE;
        }
        if (score.max_bomb_count > Tester.MAX_BOMB_COUNT) {
            score.max_bomb_count = Tester.MAX_BOMB_COUNT;
        }
        if (cell == null) {
            cell = new ScoreArray();
            cell.add(score);
            add_step(score);
            field[n] = cell;
            return;
        }
        int k = cell.size();
        for (int i = 0; i < k; ++i) {
            Score cs = cell.get(i);
            if (score.eq_level(cs)) {
                if (score.gt_short(cs)) {
                    cell.set(i, score);
/*if (score.step == 4 && cs.step == 3) {
    System.err.println("sfPut old: " + cs.toString());
    System.err.println("sfPut new: " + score.toString());
}/**/
                    remove_step(cs);
                    add_step(score);
                }
                return;
            }
        }
        cell.add(score);
        add_step(score);
    }

    public int step_size() {
        return (step.length);
    }

    public ScoreArray get_step(int n) {
        if (n >= step.length) {
            return (null);
        }
        return (step[n]);
    }

    public Score get_max_score() {

        Score rv = null;
        for (ScoreArray sa : field) {
            if (sa == null) {
                continue;
            }
            for (Score score : sa) {
/*                if (score.placed_bomb_count < Tester.MAX_PLACED_BOMB) {
                    continue;
                }/**/
                if (score.gt(rv)) {
                    rv = score;
                }
            }
        }
System.err.println("The best: " + rv.toString());
        return (rv);
    }

    public void log () {
        for (int y = 0; y < height; ++y) {
            String str = "";
            for (int x = 0; x < width; ++x) {
                ScoreArray cell = get(x, y);
                if (cell == null) {
                    str += "...... ";
                    continue;
                }
                Score max = null;
                for (Score score : cell) {
                    if (score.gt(max)) {
                        max = score;
                    }
                }
                str += String.format("%3d.%2d ", max.score*1000/max.time, max.step);
            }
            System.err.println(str);
        }
    }

    private void remove_step(Score score) {
        ScoreArray sa = step[score.step];
        if (sa == null) {
            return;
        }
//System.err.println("Remove step:" + (score == null));
//System.err.println("Remove step[]:" + (step[score.step] == null));
//System.err.println("Remove step[]:" + );
//System.err.println("Remove step:" + score.toString());
        sa.remove(score);
    }

    private void add_step(Score score) {
        if (score.placed_bomb_count >= Tester.MAX_PLACED_BOMB) {
            return;
        }
        int n = step.length;
        int k = score.step;
        if (n <= k) {
            ScoreArray[] new_step = new ScoreArray[k+1];
            System.arraycopy(step, 0, new_step, 0, n);
            step = new_step;
        }
        if (step[k] == null) {
            step[k] = new ScoreArray();
        }
//System.err.println("Add score step " + score.step + " (" + score.x + ", " + score.y + "): bombs = " + score.placed_bomb_count);
//System.err.println("Add step: " + score.toString());
        step[k].add(score);
    }
}

class Tester {
    public static final int MAX_BOMB_RANGE = 8;
    public static final int MAX_BOMB_COUNT = 4;
    public static final int MAX_PLACED_BOMB = 2;

    private Rules rules;
    private ScoreField scores;

    public Strategy find_strategy(State state) {
        rules = new Rules(state);
        scores = new ScoreField(state);
        Score in = new Score();
        in.x = state.my_x;
        in.y = state.my_y;
        in.step = 0;
        in.score = 0;
        in.time = 1;
        in.available_bombs = state.available_bombs;
        in.bombs_unavailability_time = state.bombs_unavailability_time;
        in.bomb_range = state.bomb_range;
        in.max_bomb_count = state.max_bomb_count;
        in.placed_bomb_count = 0;
        in.rules = rules;
        Score in_explode = place_bomb(in);
        for (int i = 0; i < Strategy.strategies_first.length; ++i) {
            in.strategy = i;
            in_explode.strategy = i;
//System.err.println("First strategy -" + i);
            test(Strategy.strategies_first[i], in, in_explode);
        }
        int n = Strategy.strategies_first.length;
        for (int i = 1; i < scores.step_size(); ++i) {
            ScoreArray steps = scores.get_step(i);
            if (steps == null) {
                continue;
            }
//System.err.println("Next step - " + i);
            ScoreArray steps_copy = (ScoreArray)steps.clone();
            for (Score ins : steps_copy) {
//System.err.println("Strategies for - " + ins.toString());
                in_explode = place_bomb(ins);
                for (int j = 0; j < n; ++j) {
//System.err.println("Next strategy -" + i + ", x = " + ins.y + ", x = " + ins.y);
                    test(Strategy.strategies_first[j], ins, in_explode);
                }
            }
        }
scores.log();
        return (Strategy.strategies_first[scores.get_max_score().strategy]);
    }

    private Score place_bomb(Score in) {
        Score rv = (Score)in.clone();
        rv.rules = (Rules)in.rules.clone();
        if (!rv.rules.place_bomb(rv)) {
            return (null);
        }
        return (rv);
    }

    private void test(Strategy strategy, Score in, Score in_explode) {
        Score score = strategy.explode ? (Score)in_explode.clone() : (Score)in.clone();
        if (score == null) {
//System.err.println("Test strategy - null");
            return;
        }
        if (score.rules.move_hero(score, strategy.dx, strategy.dy)) {
//System.err.println("Put strategy - " + score.toString());
            scores.put(score);
        }
    }
}

class Strategy {
    public final boolean explode;
    public final int dx, dy;
    public final boolean escape;
    public Strategy(boolean explode, int dx, int dy, boolean escape) {
        this.explode = explode;
        this.dx = dx;
        this.dy = dy;
        this.escape = escape;
    }

    public static final Strategy strategies_first[] = {
        new Strategy(true,  -1,  0, true),
        new Strategy(true,   1,  0, true),
        new Strategy(true,   0, -1, true),
        new Strategy(true,   0,  1, true),
//        new Strategy(true,   0,  0, true),
//        new Strategy(false,  0,  0, false),
        new Strategy(false, -1,  0, false),
        new Strategy(false,  1,  0, false),
        new Strategy(false,  0, -1, false),
        new Strategy(false,  0,  1, false)
    };

    public static final Strategy strategies_next[] = {
        new Strategy(true,   0,  0, true),
        new Strategy(false, -1,  0, false),
        new Strategy(false,  1,  0, false),
        new Strategy(false,  0, -1, false),
        new Strategy(false,  0,  1, false)
    };
}

/*class Point {
    public int x;
    public int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
*/

/*
class Distances extends Field {
    public Distances(Grid grid) {
        super(grid.width, grid.height);
        calc(grid);
    }

    public void calc(Grid grid) {
        Arrays.fill(field, -1);
        set(grid.my_x, grid.my_y, 0);
        ArrayList<Point> nodes = new ArrayList<Point>();
        nodes.add(new Point(grid.my_x, grid.my_y));
        int dist = 0;
        Grid prev = grid;
        Grid pull1 = null;
        Grid pull2 = null;
        while (nodes.size() > 0) {
            Grid next = prev.next_round(pull1);
            pull1 = pull2;
            pull2 = next;
            prev = next;
            nodes = make_step(next, nodes, ++dist);
        }
    }

    private ArrayList<Point> make_step(Grid grid, ArrayList<Point> nodes, int dist) {
        ArrayList<Point> rv = new ArrayList<Point>();
        for (int i = 0; i < nodes.size(); ++i) {
            int x = nodes.get(i).x;
            int y = nodes.get(i).y;
            if (x > 0 && is_possible_move(grid, x-1, y)) {
                rv.add(new Point(x-1, y));
                set(x-1, y, dist);
            }
            if (x < width-1 && is_possible_move (grid,x+1, y)) {
                rv.add(new Point(x+1, y));
                set(x+1, y, dist);
            }
            if (y > 0 && is_possible_move (grid, x, y-1)) {
                rv.add(new Point(x, y-1));
                set(x, y-1, dist);
            }
            if (y < height-1 && is_possible_move (grid, x, y+1)) {
                rv.add(new Point(x, y+1));
                set(x, y+1, dist);
            }
        }
        return (rv);
    }

    public boolean is_possible_move(Grid grid, int x, int y) {
        if (get(x,y) >= 0) {
            return (false);
        }
        int cell = grid.get_cell(x, y);
        if (cell == Grid.CELL_BOX || cell == Grid.CELL_BOMB /*|| cell == CELL_WALL || cell == CELL_EXPLOSION* /) {
            return (false);
        }
        return (true);
    }

}
*/
/*class Score_field extends Field {
    public final int max_bomb_count;
    public final int bomb_range;
    public double score[];
    public int dist[];
    public Score_field(Grid grid) {
        super(grid.width, grid.height);
        max_bomb_count = grid.max_bomb_count;
        bomb_range = grid.bomb_range;
        score = new double[field.length];
        dist = new int[field.length];
    }

    public double get_score(int x, int y) {
        return score[x + y*width];
    }

    public void set_score(int x, int y, double v) {
        score[x + y*width] = v;
    }

    public int get_dist(int x, int y) {
        return dist[x + y*width];
    }

    public void set_dist(int x, int y, int v) {
        dist[x + y*width] = v;
    }
}

class Strategy_tester {
    Grid game_state;
    public Strategy_tester(Grid grid) {
        game_state = grid;
    }

    static Strategy[] strategies = {
        new Strategy(false,  0,  0),
        new Strategy(false,  0, -1),
        new Strategy(false,  0,  1),
        new Strategy(false, -1,  0),
        new Strategy(false,  1,  0),
        new Strategy(true,   0,  0),
        new Strategy(true,   0, -1),
        new Strategy(true,   0,  1),
        new Strategy(true,  -1,  0),
        new Strategy(true,   1,  0)
    };

    public Strategy find() {
        ArrayList<Score_field> levels = new ArrayList<Score_field>();
        ArrayList<Grid> nodes = new ArrayList<Grid>();
        nodes.add(game_state);
        int dist = -1;
        while (nodes.size() != 0 && dist < 10) {
//System.err.print (": " + nodes.size());
            nodes = test(nodes, ++dist, levels, null);
//System.err.println (": " + nodes.size());
        }
//System.err.println (": bet");
        double best = 0;
        int rv = -1;
        for (Score_field sf : levels) {
            int length = sf.score.length;
            for (int i = 0; i < length; ++i) {
                if (sf.score[i] > best) {
                    best = sf.score[i];
                    rv = sf.field[i];
                }
            }
        }
        return (strategies[rv]);
    }


    ArrayList<Grid> test (ArrayList<Grid> nodes, int dist, ArrayList<Score_field> levels, Score_field map) {
        ArrayList<Grid> rv = new ArrayList<Grid>();
        for (Grid node : nodes) {
            int count = dist == 0 ? strategies.length : 5;
            for (int i = 0; i < count; ++i) {
                Strategy s = strategies[i];
                if (!node.is_possible_move(s.dx, s.dy)) {
                    continue;
                }
                Grid in = (Grid)node.clone();
                if (dist == 0) {
                    in.strategy = i;
                }
                if (s.explode) {
                    in.place_bomb();
                }
                in.move_hero(s.dx, s.dy);
                map = find(map, in, levels);
                if (map.get_score(in.my_x, in.my_y) != -1 &&
                    map.get_dist(in.my_x, in.my_y) < dist) {
                    continue;
                }
                in.tick_bombs();
                double score = test_point(in, dist+1);
                if (map.get_score(in.my_x, in.my_y) >= score) {
                    continue;
                }
                map.set_score(in.my_x, in.my_y, score);
                map.set(in.my_x, in.my_y, in.strategy);
                map.set_dist(in.my_x, in.my_y, dist);
                rv.add(in);
            }
        }
        return (rv);
    }

    double test_point(Grid grid, int dist) {
        Grid in = (Grid)grid.clone();
        while (in.available_bombs == 0) {
            ++dist;
            in.tick_bombs();
        }
        in.place_bomb();
//System.err.print (": s-" + dist);
        while (in.get_cell(in.my_x, in.my_y) == Grid.CELL_BOMB) {
            ++dist;
            in.tick_bombs();
        }
//System.err.print (": s-" + dist);
        return (in.score / (double)dist);
    }

    Score_field find(Score_field level, Grid grid, ArrayList<Score_field> levels) {
       /* if (level != null) {
            return (level);
        }
        if (levels.size() != 0) {
            return levels.get(0);
        }* /
        int max_bomb_count =  Math.min(grid.max_bomb_count, 4);
        int bomb_range =  Math.min(grid.bomb_range, 13);
        if (level != null && level.max_bomb_count == max_bomb_count && level.bomb_range == bomb_range) {
            return (level);
        }
        for (Score_field l : levels) {
            if (l.max_bomb_count == max_bomb_count && l.bomb_range == bomb_range) {
                return (l);
            }
        }
        Score_field rv = new Score_field(grid);
        Arrays.fill(rv.score, -1);
        levels.add(rv);
        return (rv);
    }
}
/*
    public Grid next_round(Grid pull) {
        return next_round(pull, false, 0, 0);
    }

    public Grid next_round(Grid pull, boolean new_bomb, int dx, int dy) {
        Grid rv = pull;
        if (rv == null) {
            try {
                rv = (Grid)clone();
            }
            catch (Exception e) {}
        }
        rv.my_x = my_x;
        rv.my_y = my_y;
        rv.available_bombs = available_bombs;
        rv.bombs_unavailability_time = bombs_unavailability_time;
        rv.bomb_range = bomb_range;
        rv.max_bomb_count = max_bomb_count;
        rv.score = score;
        rv.strategy = strategy;
        System.arraycopy(grid.field, 0, rv.grid.field, 0, grid.field.length);
        rv.items = (ArrayList<Integer>)items.clone();

        if (new_bomb) {
            rv.place_bomb();
        }
        rv.move_hero(dx, dy);
        rv.tick_bombs();
        return (rv);
    }

    void tick_bombs() {

        int rv = 0;
        --bombs_unavailability_time;
        Item it = null;
        boolean t = false;
        for (int i = item_count()-1; i >= 0; --i) {
            it = get_item(i, it);
            if (it.type == Item.TYPE_BOMB) {
                if (it.param1 <= 0) {
                    remove_item(i);
                    t = true;
                }
            }
        }
        if (t) {
            int count = grid.size();
            for (int i = 0; i < count; ++i) {
                if (grid.field[i] == CELL_EXPLOSION) {
                    grid.field[i] = CELL_EMPTY;
                }
            }
Player.dprint("tick_bombs : ");
        }
        for (int i = item_count()-1; i >= 0; --i) {
Player.dprint("tick_bombs 2 : ");
            it = get_item(i, it);
            if (it.type == Item.TYPE_BOMB) {
                if (--it.param1 >= 0) {
                    modify_item(i, it);
                }
                if (it.param1 == 0) {
                    rv += explode_bomb(it);
                }
            }
        }
        score += rv;
    }

    class foo {
        public int score = 0;
        public final boolean my_bomb;
        public foo (boolean my) {
            my_bomb = my;
        }
    }

    int explode_bomb(Item b) {
        foo rv = new foo(b.owner == my_id);
        if (rv.my_bomb) {
            ++available_bombs;
        }
        set_cell(b.x, b.y, CELL_EMPTY);
        int range = b.param2-1;
        int fin;
        Item it = null;

        fin = b.x - range;
        if (fin < 0) {
            fin = 0;
        }
        for (int i = b.x; i >= fin && explode_cell(i, b.y, rv); --i)
            ;

        fin = b.x + range;
        if (fin >= width) {
            fin = width - 1;
        }
        for (int i = b.x+1; i <= fin && explode_cell(i, b.y, rv); ++i)
            ;

        fin = b.y - range;
        if (fin < 0) {
            fin = 0;
        }
        for (int i = b.y-1; i >= fin && explode_cell(b.x, i, rv); --i)
            ;

        fin = b.y + range;
        if (fin >= height) {
            fin = height - 1;
        }
        for (int i = b.y+1; i <= fin && explode_cell(b.x, i, rv); ++i)
            ;
        return (rv.score);
    }

    boolean explode_cell (int x, int y, foo score) {
        boolean rv = true;
        Item it = new Item();
        switch (get_cell(x, y)) {
            case CELL_BOMB:
                int n = find_item(0, x, y, it);
                while (n != -1) {
                    if (it.type == Item.TYPE_BOMB && it.param1 != 0) {
                        it.param1 = 0;
                        modify_item(n, it);
                        score.score += explode_bomb(it);
                    }
                    n = find_item(n, x, y, it);
                }
                rv = false;
                break;
            case CELL_BOX:
                set_cell(x, y, CELL_EXPLOSION);
                if (score.my_bomb) {
                    ++score.score;
                }
                rv = false;
                break;
            case CELL_EMPTY:
            case CELL_EXPLOSION:
                set_cell(x, y, CELL_EXPLOSION);
                break;
            case CELL_WALL:
                rv = false;
                break;
            default:
                set_cell(x, y, CELL_EXPLOSION);
                rv = false;
                break;
        }
        return (rv);
    }

    void place_bomb() {
        if (available_bombs > 0) {
            items.add(compact_item(my_x, my_y, Item.TYPE_BOMB, my_id, 9, bomb_range));
            set_cell(my_x, my_y, CELL_BOMB);
            --available_bombs;
            bombs_unavailability_time = 9;
        }
    }

    void move_hero(int dx, int dy) {
        if (dx != 0 || dy != 0) {
            my_x += dx;
            my_y += dy;
            if (my_x < 0 || my_x >= width || my_y < 0 || my_y >= height) {
                System.err.println("Not possible move to - (" + my_x + ", " + my_y);
                System.exit(1);
            }
            int cell = get_cell(my_x, my_y);
            if (cell == CELL_EXTRA_BOMB) {
                ++max_bomb_count;
                ++available_bombs;
                set_cell(my_x, my_y, CELL_EMPTY);
            }
            if (cell == CELL_EXTRA_RANGE) {
                ++bomb_range;
                set_cell(my_x, my_y, CELL_EMPTY);
            }
        }
    }

    public boolean is_possible_move(int dx, int dy) {
        int x = my_x + dx;
        int y = my_y + dy;
        if (x < 0 || x >= width || y < 0 || y >= height) {
            return (false);
        }
        int cell = get_cell(x, y);
        if (cell == CELL_BOX || cell == CELL_BOMB /*|| cell == CELL_WALL || cell == CELL_EXPLOSION* /) {
            return (false);
        }
        return (true);
    }
*/