import java.util.*;
import java.io.*;
import java.math.*;

/**
 * Auto-generated code below aims at helping you parse
 * the standard input according to the problem statement.
 **/
class Player {

    static final int BOMB_RANGE = 2;

    static Grid grid = null;
    static int grid_weights[][];
    static int distances[][];
    static int my_x, my_y, width, height;
    static int available_bombs, bombs_unavailability_time;

    static long enterTime = 0;
    public static void dprint(String s) {
        long d = System.nanoTime() - enterTime;
        if (d > 17000000) {
            System.err.println(s + d);
        }
    }

    public static void main(String args[]) {
        Runtime r = Runtime.getRuntime();
        Scanner in = new Scanner(System.in);
        int width = in.nextInt();
        int height = in.nextInt();
        int my_id = in.nextInt();
        in.nextLine();

        grid = new Grid(width, height, my_id);
        //grid_weights = create_field(width, height);

        // game loop
        while (true) {
            for (int i = 0; i < height; i++) {
                String row = in.nextLine();
                grid.init_row(i, row);
            }

            int entities = in.nextInt();
            bombs_unavailability_time = 10;
            for (int i = 0; i < entities; i++) {
                int entity_type = in.nextInt();
                int owner = in.nextInt();
                int x = in.nextInt();
                int y = in.nextInt();
                int param1 = in.nextInt();
                int param2 = in.nextInt();
                grid.put_entity(x, y, entity_type, owner, param1, param2);
            }
            in.nextLine();

            String action = do_move();
            // Write an action using System.out.println()
            // To debug: System.err.println("Debug messages...");

            System.out.println(action);
            r.gc();
        }
    }

    static String do_move() {
enterTime = System.nanoTime();

        Strategy_tester tester = new Strategy_tester(grid);
        Strategy s = tester.find();
        String rv = (s.explode ? "BOMB " : "MOVE ") + (grid.my_x+s.dx) + " " + (grid.my_y+s.dy);
System.err.print (": do_move() " + (System.nanoTime()-enterTime));
        return (rv);
    }

/*    static void print_field(int field[][]) {
        for (int i = 0; i < field[0].length; ++i) {
            for (int j = 0; j < field.length; ++j) {
                int cell = field[j][i];
                //System.err.print(cell);
                char ch = '.';
                if (cell > 0) {
                    ch = '^';
                    if (cell <= 9) {
                        ch = (char)('0' + cell);
                    }
                    else if (cell <= 10 + 'z' - 'a') {
                        ch = (char)('a' + cell - 10);
                    }
                }
                if (cell < 0) {
                    ch = '~';
                    if (cell >= 'A' - 'Z' - 1) {
                        ch = (char)('A' - cell - 1);
                    }
                }
                System.err.print(ch);
            }
            System.err.println();
        }
    }*/

/*    static void calc_weights() {
        for (int x = 0; x < width; ++x) {
            for (int y = 0; y < height; ++y) {
                if (grid[x][y] == CELL_BOX) {
                    continue;
                }
                int weight = 0;
                for (int i = x - BOMB_RANGE; i <= x + BOMB_RANGE; ++i) {
                    if (i >= 0 && i < width && grid[i][y] == CELL_BOX) {
                        ++weight;
                    }
                }
                for (int i = y - BOMB_RANGE; i <= y + BOMB_RANGE; ++i) {
                    if (i >= 0 && i < height && grid[x][i] == CELL_BOX) {
                        ++weight;
                    }
                }
                grid_weights[x][y] = weight;
            }
        }
    }

    static Point find_next_bomb_place() {
        Point rv = null;
        int weight = 0;
        double speed = 0;
        for (int x = 0; x < width; ++x) {
            for (int y = 0; y < height; ++y) {
                int point_weight = grid_weights[x][y];
                int point_distance = distances[x][y];
                if (point_weight <= 0 || point_distance == 0) {
                    continue;
                }
                if (available_bombs <= 0 || point_distance < bombs_unavailability_time) {
                    point_distance = bombs_unavailability_time;
                }
                double point_speed = ((double)point_weight) / point_distance;
                if (point_speed > speed || (point_speed == speed && point_weight > weight)) {
                    weight = point_weight;
                    speed = point_speed;
                    if (rv == null) {
                        rv = new Point(x, y);
                    }
                    else {
                        rv.x = x;
                        rv.y = y;
                    }
                }
            }
        }
        return (rv);
    }*/
}

class Item {
    public static final int TYPE_PLAYER             = 0;
    public static final int TYPE_BOMB               = 1;
    public static final int TYPE_ITEM               = 2; // используется только при инициализации
    public static final int TYPE_EXTRA_BOMB         = 3;
    public static final int TYPE_EXTRA_RANGE        = 4;

    public int x;
    public int y;
    public int type;
    public int owner;
    public int param1;
    public int param2;

    public Item (int x, int y, int type, int owner, int param1, int param2) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.owner = owner;
        this.param1 = param1;
        this.param2 = param2;
    }

    public Item() {
    }
}

class Point {
    public int x;
    public int y;
    public Grid grid;
    public Point(Grid grid, int x, int y) {
        this.x = x;
        this.y = y;
        this.grid = grid;
    }
}

class Strategy {
    public boolean explode;
    public int dx, dy;
    public Strategy(boolean explode, int dx, int dy) {
        this.explode = explode;
        this.dx = dx;
        this.dy = dy;
    }
}

class Grid implements Cloneable {
    public static final int CELL_EMPTY              = 0;
    public static final int CELL_BOX                = 1;
    public static final int CELL_BOMB               = 2;
    public static final int CELL_EXTRA_BOMB         = 3;
    public static final int CELL_EXTRA_RANGE        = 4;
    public static final int CELL_EXPLOSION          = 5;
    public static final int CELL_WALL               = 6;
    public static final int CELL_PLAYER_0           = 7;
    public static final int CELL_PLAYER_1           = 8;

    public final int width;
    public final int height;
    public final int my_id;
    public int my_x, my_y;
    public int available_bombs = 0;
    public int bombs_unavailability_time = 10;
    public int bomb_range = 0;
    public int max_bomb_count = 0;
    public int score = 0;
    public int strategy = 0;
    private Field grid = null;
    private ArrayList<Integer> items = null;

    public Grid (int width, int height, int my_id) {
        this.width = width;
        this.height = height;
        this.my_id = my_id;
    }

    public void init_row(int n, String row) {
        if (grid == null) {
            grid = new Field(width, height);
        }
        int length = row.length();
        int start_pos = n * width;
        for (int i = 0; i < length; ++i) {
            int cell = CELL_EMPTY;
            char ch = row.charAt(i);
            switch (ch) {
                case '.':
                    break;
                default:
                    cell = CELL_BOX;
                    break;
            }
            grid.field[start_pos+i] = cell;
        }
    }

    public int get_cell(int x, int y) {
        return (grid.get(x, y));
    }

    void set_cell(int x, int y, int type) {
        grid.set(x, y, type);
    }

    public void put_entity (int x, int y, int type, int owner, int param1, int param2) {
        if (items == null) {
            items = new ArrayList<Integer>(64);
        }
        if (type == Item.TYPE_ITEM && get_cell(x, y) == CELL_EMPTY) {
            set_cell(x, y, param1 == 1 ? CELL_EXTRA_RANGE : CELL_EXTRA_BOMB);
            return;
        }
        if (type == Item.TYPE_PLAYER) {
            if (owner == my_id) {
                my_x = x;
                my_y = y;
                available_bombs = param1;
                max_bomb_count += param1;
                bomb_range = param2;
            }
            int cell = get_cell(x, y);
            if (owner < my_id || cell == CELL_EMPTY || cell == CELL_EXTRA_RANGE || cell == CELL_EXTRA_BOMB) {
                set_cell(x, y, CELL_PLAYER_0+owner);
            }
            return;
        }
        if (type == Item.TYPE_BOMB) {
            set_cell(x, y, CELL_BOMB);
            if (owner == my_id && param1 < bombs_unavailability_time) {
                bombs_unavailability_time = param1;
                ++max_bomb_count;
            }
        }
        items.add(compact_item(x, y, type, owner, param1, param2));
    }

    private int compact_item(int x, int y, int type, int owner, int param1, int param2) {
        if (param1 > 15) {
            param1 = 15;
        }
        if (param2 > 15) {
            param2 = 15;
        }
        return(x << 20 | y << 16 | type << 12 | owner << 8 | param1 << 4 | param2);
    }

    public int item_count() {
        return (items.size());
    }

    public Item get_item (int n, Item dst) {
        int it = items.get(n);
        if (dst == null) {
            return new Item((it >> 20) & 0xf, (it >> 16) & 0xf, (it >> 12) & 0xf, (it >> 8) & 0xf, (it >> 4) & 0xf, it & 0xf);
        }
        dst.x = (it >> 20) & 0xf;
        dst.y = (it >> 16) & 0xf;
        dst.type = (it >> 12) & 0xf;
        dst.owner = (it >> 8) & 0xf;
        dst.param1 = (it >> 4) & 0xf;
        dst.param2 = it & 0xf;
        return (dst);
    }

    public void remove_item(int n) {
        items.remove(n);
    }

    public void modify_item(int n, Item it) {
        items.set(n, compact_item(it.x, it.y, it.type, it.owner, it.param1, it.param2));
    }

    @Override
    public Object clone()  {
        Grid copy = null;
        try {
            copy = (Grid)super.clone();
            copy.grid = (Field)grid.clone();
            copy.items = (ArrayList<Integer>)items.clone();
        }
        catch (Exception e) {
            System.err.println("Can't clone some objects");
            System.exit(1);
        }
        return (copy);
    }

    public Grid next_round(Grid pull) {
        return next_round(pull, false, 0, 0);
    }

    public Grid next_round(Grid pull, boolean new_bomb, int dx, int dy) {
        Grid rv = pull;
        if (rv == null) {
            try {
                rv = (Grid)clone();
            }
            catch (Exception e) {}
        }
        rv.my_x = my_x;
        rv.my_y = my_y;
        rv.available_bombs = available_bombs;
        rv.bombs_unavailability_time = bombs_unavailability_time;
        rv.bomb_range = bomb_range;
        rv.max_bomb_count = max_bomb_count;
        rv.score = score;
        rv.strategy = strategy;
        System.arraycopy(grid.field, 0, rv.grid.field, 0, grid.field.length);
        rv.items = (ArrayList<Integer>)items.clone();

        if (new_bomb) {
            rv.place_bomb();
        }
        rv.move_hero(dx, dy);
        rv.tick_bombs();
        return (rv);
    }

    void tick_bombs() {

        int rv = 0;
        --bombs_unavailability_time;
        Item it = null;
        boolean t = false;
        for (int i = item_count()-1; i >= 0; --i) {
            it = get_item(i, it);
            if (it.type == Item.TYPE_BOMB) {
                if (it.param1 <= 0) {
                    remove_item(i);
                    t = true;
                }
            }
        }
        if (t) {
            int count = grid.size();
            for (int i = 0; i < count; ++i) {
                if (grid.field[i] == CELL_EXPLOSION) {
                    grid.field[i] = CELL_EMPTY;
                }
            }
Player.dprint("tick_bombs : ");
        }
        for (int i = item_count()-1; i >= 0; --i) {
Player.dprint("tick_bombs 2 : ");
            it = get_item(i, it);
            if (it.type == Item.TYPE_BOMB) {
                if (--it.param1 >= 0) {
                    modify_item(i, it);
                }
                if (it.param1 == 0) {
                    rv += explode_bomb(it);
                }
            }
        }
        score += rv;
    }

    class foo {
        public int score = 0;
        public final boolean my_bomb;
        public foo (boolean my) {
            my_bomb = my;
        }
    }

    int explode_bomb(Item b) {
        foo rv = new foo(b.owner == my_id);
        if (rv.my_bomb) {
            ++available_bombs;
        }
        set_cell(b.x, b.y, CELL_EMPTY);
        int range = b.param2-1;
        int fin;
        Item it = null;

        fin = b.x - range;
        if (fin < 0) {
            fin = 0;
        }
        for (int i = b.x; i >= fin && explode_cell(i, b.y, rv, b); --i)
            ;

        fin = b.x + range;
        if (fin >= width) {
            fin = width - 1;
        }
        for (int i = b.x+1; i <= fin && explode_cell(i, b.y, rv, b); ++i)
            ;

        fin = b.y - range;
        if (fin < 0) {
            fin = 0;
        }
        for (int i = b.y-1; i >= fin && explode_cell(b.x, i, rv, b); --i)
            ;

        fin = b.y + range;
        if (fin >= height) {
            fin = height - 1;
        }
        for (int i = b.y+1; i <= fin && explode_cell(b.x, i, rv, b); ++i)
            ;
        return (rv.score);
    }

    boolean explode_cell (int x, int y, foo score, Item b) {
        boolean rv = true;
        Item it = new Item();
        switch (get_cell(x, y)) {
            case CELL_BOMB:
                int n = find_item(0, x, y, it);
                while (n != -1) {
                    if (it.type == Item.TYPE_BOMB && it.param1 != 0 &&
                        b.owner != it.owner) {
                        it.param1 = 0;
                        modify_item(n, it);
                        score.score += explode_bomb(it);
                    }
                    n = find_item(n, x, y, it);
                }
                rv = false;
                break;
            case CELL_BOX:
                set_cell(x, y, CELL_EXPLOSION);
                if (score.my_bomb) {
                    ++score.score;
                }
                rv = false;
                break;
            case CELL_EMPTY:
            case CELL_EXPLOSION:
                set_cell(x, y, CELL_EXPLOSION);
                break;
            case CELL_WALL:
                rv = false;
                break;
            default:
                set_cell(x, y, CELL_EXPLOSION);
                rv = false;
                break;
        }
        return (rv);
    }

    int find_item(int n, int x, int y, Item it) {
        int count = item_count();
        for (int i = n; i < count; ++i) {
            it = get_item(i, it);
            if (it.x == x && it.y == y) {
                return (i);
            }
        }
        return (-1);
    }

    void place_bomb() {
        if (available_bombs > 0) {
            items.add(compact_item(my_x, my_y, Item.TYPE_BOMB, my_id, 9, bomb_range));
            set_cell(my_x, my_y, CELL_BOMB);
            --available_bombs;
            bombs_unavailability_time = 9;
        }
    }

    void move_hero(int dx, int dy) {
        if (dx != 0 || dy != 0) {
            my_x += dx;
            my_y += dy;
            if (my_x < 0 || my_x >= width || my_y < 0 || my_y >= height) {
                System.err.println("Not possible move to - (" + my_x + ", " + my_y);
                System.exit(1);
            }
            int cell = get_cell(my_x, my_y);
            if (cell == CELL_EXTRA_BOMB) {
                ++max_bomb_count;
                ++available_bombs;
                set_cell(my_x, my_y, CELL_EMPTY);
            }
            if (cell == CELL_EXTRA_RANGE) {
                ++bomb_range;
                set_cell(my_x, my_y, CELL_EMPTY);
            }
        }
    }

    public boolean is_possible_move(int dx, int dy) {
        int x = my_x + dx;
        int y = my_y + dy;
        if (x < 0 || x >= width || y < 0 || y >= height) {
            return (false);
        }
        int cell = get_cell(x, y);
        if (cell == CELL_BOX || cell == CELL_BOMB /*|| cell == CELL_WALL || cell == CELL_EXPLOSION*/) {
            return (false);
        }
        return (true);
    }
}

class Field implements Cloneable {
    public final int width;
    public final int height;
    public int[] field = null;

    public Field (int width, int height) {
        this.width = width;
        this.height = height;
        field = new int[width*height];
    }

    public int get(int x, int y) {
        return (field[x + y*width]);
    }

    public void set(int x, int y, int val) {
        field[x + y*width] = val;
    }

    public int size() {
        return field.length;
    }

    public Object clone() {
        Field copy = null;
        try {
            copy = (Field)super.clone();
            copy.field = field.clone();
        }
        catch (Exception e) {
            System.err.println("Can't clone some objects");
            System.exit(1);
        }
        return (copy);
    }
}
/*
class Distances extends Field {
    public Distances(Grid grid) {
        super(grid.width, grid.height);
        calc(grid);
    }

    public void calc(Grid grid) {
        Arrays.fill(field, -1);
        set(grid.my_x, grid.my_y, 0);
        ArrayList<Point> nodes = new ArrayList<Point>();
        nodes.add(new Point(grid.my_x, grid.my_y));
        int dist = 0;
        Grid prev = grid;
        Grid pull1 = null;
        Grid pull2 = null;
        while (nodes.size() > 0) {
            Grid next = prev.next_round(pull1);
            pull1 = pull2;
            pull2 = next;
            prev = next;
            nodes = make_step(next, nodes, ++dist);
        }
    }

    private ArrayList<Point> make_step(Grid grid, ArrayList<Point> nodes, int dist) {
        ArrayList<Point> rv = new ArrayList<Point>();
        for (int i = 0; i < nodes.size(); ++i) {
            int x = nodes.get(i).x;
            int y = nodes.get(i).y;
            if (x > 0 && is_possible_move(grid, x-1, y)) {
                rv.add(new Point(x-1, y));
                set(x-1, y, dist);
            }
            if (x < width-1 && is_possible_move (grid,x+1, y)) {
                rv.add(new Point(x+1, y));
                set(x+1, y, dist);
            }
            if (y > 0 && is_possible_move (grid, x, y-1)) {
                rv.add(new Point(x, y-1));
                set(x, y-1, dist);
            }
            if (y < height-1 && is_possible_move (grid, x, y+1)) {
                rv.add(new Point(x, y+1));
                set(x, y+1, dist);
            }
        }
        return (rv);
    }

    public boolean is_possible_move(Grid grid, int x, int y) {
        if (get(x,y) >= 0) {
            return (false);
        }
        int cell = grid.get_cell(x, y);
        if (cell == Grid.CELL_BOX || cell == Grid.CELL_BOMB /*|| cell == CELL_WALL || cell == CELL_EXPLOSION* /) {
            return (false);
        }
        return (true);
    }

}
*/
class Score_field extends Field {
    public final int max_bomb_count;
    public final int bomb_range;
    public double score[];
    public int dist[];
    public Score_field(Grid grid) {
        super(grid.width, grid.height);
        max_bomb_count = grid.max_bomb_count;
        bomb_range = grid.bomb_range;
        score = new double[field.length];
        dist = new int[field.length];
    }

    public double get_score(int x, int y) {
        return score[x + y*width];
    }

    public void set_score(int x, int y, double v) {
        score[x + y*width] = v;
    }

    public int get_dist(int x, int y) {
        return dist[x + y*width];
    }

    public void set_dist(int x, int y, int v) {
        dist[x + y*width] = v;
    }
}

class Strategy_tester {
    Grid game_state;
    public Strategy_tester(Grid grid) {
        game_state = grid;
    }

    static Strategy[] strategies = {
        new Strategy(false,  0,  0),
        new Strategy(false,  0, -1),
        new Strategy(false,  0,  1),
        new Strategy(false, -1,  0),
        new Strategy(false,  1,  0),
        new Strategy(true,   0,  0),
        new Strategy(true,   0, -1),
        new Strategy(true,   0,  1),
        new Strategy(true,  -1,  0),
        new Strategy(true,   1,  0)
    };

    public Strategy find() {
        ArrayList<Score_field> levels = new ArrayList<Score_field>();
        ArrayList<Grid> nodes = new ArrayList<Grid>();
        nodes.add(game_state);
        int dist = -1;
        while (nodes.size() != 0 && dist < 10) {
//System.err.print (": " + nodes.size());
            nodes = test(nodes, ++dist, levels, null);
//System.err.println (": " + nodes.size());
        }
//System.err.println (": bet");
        double best = 0;
        int rv = -1;
        for (Score_field sf : levels) {
            int length = sf.score.length;
            for (int i = 0; i < length; ++i) {
                if (sf.score[i] > best) {
                    best = sf.score[i];
                    rv = sf.field[i];
                }
            }
        }
        return (strategies[rv]);
    }


    ArrayList<Grid> test (ArrayList<Grid> nodes, int dist, ArrayList<Score_field> levels, Score_field map) {
        ArrayList<Grid> rv = new ArrayList<Grid>();
        for (Grid node : nodes) {
            int count = dist == 0 ? strategies.length : 5;
            for (int i = 0; i < count; ++i) {
                Strategy s = strategies[i];
                if (!node.is_possible_move(s.dx, s.dy)) {
                    continue;
                }
                Grid in = (Grid)node.clone();
                if (dist == 0) {
                    in.strategy = i;
                }
                if (s.explode) {
                    in.place_bomb();
                }
                in.move_hero(s.dx, s.dy);
                map = find(map, in, levels);
                if (map.get_score(in.my_x, in.my_y) != -1 &&
                    map.get_dist(in.my_x, in.my_y) < dist) {
                    continue;
                }
                in.tick_bombs();
                double score = test_point(in, dist+1);
                if (map.get_score(in.my_x, in.my_y) >= score) {
                    continue;
                }
                map.set_score(in.my_x, in.my_y, score);
                map.set(in.my_x, in.my_y, in.strategy);
                map.set_dist(in.my_x, in.my_y, dist);
                rv.add(in);
            }
        }
        return (rv);
    }

    double test_point(Grid grid, int dist) {
        Grid in = (Grid)grid.clone();
        while (in.available_bombs == 0) {
            ++dist;
            in.tick_bombs();
        }
        in.place_bomb();
//System.err.print (": s-" + dist);
        while (in.get_cell(in.my_x, in.my_y) == Grid.CELL_BOMB) {
            ++dist;
            in.tick_bombs();
        }
//System.err.print (": s-" + dist);
        return (in.score / (double)dist);
    }

    Score_field find(Score_field level, Grid grid, ArrayList<Score_field> levels) {
       /* if (level != null) {
            return (level);
        }
        if (levels.size() != 0) {
            return levels.get(0);
        }*/
        int max_bomb_count =  Math.min(grid.max_bomb_count, 4);
        int bomb_range =  Math.min(grid.bomb_range, 13);
        if (level != null && level.max_bomb_count == max_bomb_count && level.bomb_range == bomb_range) {
            return (level);
        }
        for (Score_field l : levels) {
            if (l.max_bomb_count == max_bomb_count && l.bomb_range == bomb_range) {
                return (l);
            }
        }
        Score_field rv = new Score_field(grid);
        Arrays.fill(rv.score, -1);
        levels.add(rv);
        return (rv);
    }
}